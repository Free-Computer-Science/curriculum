# Foundations Module
This Foundations Module ensures that students develop a comprehensive understanding of both theoretical and practical aspects of computer science, setting them up for success in more specialized and advanced studies.

## Introduction to Programming

Summary: This course covers the basics of computer science, providing an introduction to programming, algorithms, and data structures. It focuses on building problem-solving skills and serves as a prerequisite for all subsequent courses. Students will gain foundational knowledge in programming concepts, which are essential for understanding more advanced topics.

Part 1: Intro to Computer Science
1. What is Programming
2. The History of Computers
3. The Parts of the Computer
4. Programming Languages
5. Why Python?
6. Installing and Using Python
7. Our First Program

Part 2: Intro to programming

1. Functions, Variables — Notes — Problem Set
2. Conditionals — Notes — Problem Set
3. Loops — Notes — Problem Set
4. Exceptions — Notes — Problem Set
5. Libraries — Notes — Problem Set
6. Unit Tests — Notes — Problem Set
7. File I/O — Notes — Problem Set
8. Regular Expressions — Notes — Problem Set
9. Object-Oriented Programming — Notes — Problem Set
10. Et Cetera — Notes — Final Project


## AP Computer Science Principles

    Summary: A high school-level course designed to introduce students to the foundational principles of computing. It covers a broad range of topics including the internet, data analysis, and the societal impacts of computing. This course is excellent preparation for more advanced programming courses and helps students understand the broader context of computer science.

Lessons:
### Unit 1: The Internet
Lesson 1: Introduction to the Internet

    Objective: Understand what the internet is and how it functions as a network of networks.
    Content:
        Basics of the internet
        How devices connect to the internet
        The concept of the World Wide Web

Lesson 2: IP Addresses and Domain Names

    Objective: Learn how IP addresses and domain names identify devices on the internet.
    Content:
        Structure of IP addresses (IPv4 vs. IPv6)
        How domain names map to IP addresses (DNS)
        Importance of DNS in internet functionality

Lesson 3: Packet Switching

    Objective: Understand how data is transmitted over the internet using packet switching.
    Content:
        Definition and explanation of packet switching
        How packets are routed across networks
        The role of routers and switches

Lesson 4: HTTP and HTTPS

    Objective: Learn about the protocols that enable web browsing: HTTP and HTTPS.
    Content:
        Basics of the HTTP protocol
        Secure HTTP (HTTPS) and encryption
        How browsers and servers communicate

Lesson 5: Internet Reliability and Redundancy

    Objective: Understand the concepts of internet reliability and redundancy.
    Content:
        Importance of redundancy in network paths
        How the internet remains reliable despite failures
        Concepts of fault tolerance

Lesson 6: The Digital Divide

    Objective: Discuss the impact of the digital divide on society.
    Content:
        Definition of the digital divide
        Causes and consequences of the digital divide
        Efforts to bridge the digital divide

### Unit 2: Data and Information

Lesson 7: Data Representation

    Objective: Understand how data is represented digitally.
    Content:
        Binary and hexadecimal number systems
        How text, images, and sounds are represented in binary
        Introduction to ASCII and Unicode

Lesson 8: Data Compression

    Objective: Learn about the techniques and importance of data compression.
    Content:
        Lossless vs. lossy compression
        Common compression algorithms (e.g., Huffman coding, JPEG)
        Trade-offs between compression and quality

Lesson 9: Big Data

    Objective: Explore the concept of big data and its impact on society.
    Content:
        Definition of big data
        How big data is collected, stored, and analyzed
        Applications and ethical considerations of big data

Lesson 10: Data Privacy and Security

    Objective: Understand the importance of data privacy and security.
    Content:
        Concepts of data encryption and decryption
        Privacy concerns and data breaches
        Laws and regulations governing data privacy (e.g., GDPR)

### Unit 3: Algorithms and Programming

Lesson 11: What is an Algorithm?

    Objective: Define what an algorithm is and understand its role in problem-solving.
    Content:
        Definition of an algorithm
        Examples of simple algorithms
        The importance of algorithmic thinking

Lesson 12: Sequencing, Selection, and Iteration

    Objective: Learn the basic control structures used in programming: sequencing, selection, and iteration.
    Content:
        How sequencing controls the order of execution
        Selection using if-statements
        Iteration using loops (for, while)

Lesson 13: Variables and Data Types

    Objective: Understand the use of variables and data types in programming.
    Content:
        Definition and declaration of variables
        Common data types (int, float, string, boolean)
        Assigning and manipulating variables

Lesson 14: Functions and Procedures

    Objective: Learn how to create and use functions and procedures in programming.
    Content:
        Definition of functions and procedures
        How to pass arguments and return values
        The importance of modular programming

Lesson 15: Lists and Arrays

    Objective: Understand how to use lists and arrays to store collections of data.
    Content:
        Creating and accessing elements in lists/arrays
        Common operations on lists (insert, delete, search)
        Differences between lists and arrays

Lesson 16: Debugging and Testing

    Objective: Learn the basics of debugging and testing programs.
    Content:
        Common debugging techniques
        Writing test cases to validate code
        Importance of thorough testing

### Unit 4: Abstraction

Lesson 17: What is Abstraction?

    Objective: Understand the concept of abstraction and its importance in computer science.
    Content:
        Definition of abstraction
        Examples of abstraction in daily life
        How abstraction simplifies complex systems

Lesson 18: Procedural Abstraction

    Objective: Learn how procedural abstraction is used in programming.
    Content:
        How functions represent abstraction in code
        The benefits of using procedures/functions
        Examples of procedural abstraction in programs

Lesson 19: Data Abstraction

    Objective: Understand how data abstraction helps manage complexity.
    Content:
        Concepts of data encapsulation and information hiding
        How abstract data types (ADTs) simplify program design
        Examples of data abstraction in software development

### Unit 5: The Impact of Computing

Lesson 20: Computing Innovations

    Objective: Explore the impact of various computing innovations on society.
    Content:
        Case studies of significant computing innovations
        How computing has transformed industries (e.g., healthcare, education)
        Ethical considerations of technological advancements

Lesson 21: Legal and Ethical Issues in Computing

    Objective: Understand the legal and ethical issues related to computing.
    Content:
        Intellectual property and copyright laws
        Ethical dilemmas in computing (e.g., AI, privacy)
        Case studies of legal and ethical challenges

Lesson 22: The Role of Government in Technology

    Objective: Learn about the government’s role in regulating and supporting technology.
    Content:
        Government regulations on data privacy and cybersecurity
        Government funding for technological research and development
        The balance between innovation and regulation

Lesson 23: Global Impact of Computing

    Objective: Discuss the global impact of computing and technology.
    Content:
        How technology has affected globalization
        The digital divide on a global scale
        Efforts to make technology accessible worldwide

Lesson 24: Careers in Computing

    Objective: Explore the various career paths available in computing.
    Content:
        Overview of different computing careers (e.g., software engineering, data science)
        The skills and education needed for each career
        The future of jobs in technology

## AP Computer Science A

    Summary: This high school-level course focuses on object-oriented programming using Java. It covers fundamental programming concepts like variables, control structures, arrays, and basic algorithms. Serving as a stepping stone to more advanced programming and data structure courses, this course helps students develop a solid understanding of programming principles.

### Unit 1: Introduction to Java

Lesson 1: Setting Up the Development Environment

    Objective: Install and configure the Java Development Kit (JDK) and an Integrated Development Environment (IDE).
    Content:
        Downloading and installing JDK
        Setting up an IDE (e.g., IntelliJ, Eclipse)
        Writing and running your first Java program

Lesson 2: Understanding Java Syntax

    Objective: Learn the basic syntax and structure of a Java program.
    Content:
        Anatomy of a Java program (classes, methods, main method)
        Writing simple output using System.out.println()
        Comments and code readability

Lesson 3: Variables and Data Types

    Objective: Understand how to declare and use variables in Java.
    Content:
        Primitive data types (int, double, boolean, char)
        Declaring and initializing variables
        Variable naming conventions and scope

Lesson 4: Operators and Expressions

    Objective: Learn how to use operators and create expressions in Java.
    Content:
        Arithmetic, relational, and logical operators
        Order of operations and precedence
        Writing and evaluating expressions

Lesson 5: Input and Output in Java

    Objective: Learn how to read user input and display output in Java.
    Content:
        Using Scanner for input
        Formatting output
        Handling basic input validation

### Unit 2: Control Structures

Lesson 6: Conditional Statements (if, else, else-if)

    Objective: Understand how to use conditional statements to control the flow of a program.
    Content:
        Writing if, else, and else-if statements
        Nested conditionals
        Best practices for writing clean, readable conditionals

Lesson 7: Switch Statements

    Objective: Learn how to use switch statements as an alternative to multiple if-else conditions.
    Content:
        Syntax of switch statements
        When to use switch vs. if-else
        Handling multiple cases and the default case

Lesson 8: Loops: while and do-while

    Objective: Understand how to use while and do-while loops for repeated execution.
    Content:
        Writing while loops and do-while loops
        Infinite loops and loop control
        Common use cases for each type of loop

Lesson 9: Loops: for and Enhanced for Loop

    Objective: Learn how to use for loops and the enhanced for-each loop.
    Content:
        Writing traditional for loops
        Using the enhanced for loop for arrays and collections
        Looping with complex conditions

Lesson 10: Nested Loops

    Objective: Understand how to use nested loops to solve more complex problems.
    Content:
        Writing loops within loops
        Applications of nested loops (e.g., matrix processing)
        Analyzing the time complexity of nested loops

### Unit 3: Object-Oriented Programming

Lesson 11: Introduction to Objects and Classes

    Objective: Understand the concept of objects and classes in Java.
    Content:
        Defining and creating classes and objects
        Understanding the new keyword
        Basic object manipulation (calling methods, accessing fields)

Lesson 12: Defining Methods

    Objective: Learn how to define and use methods in Java.
    Content:
        Method declaration (return type, method name, parameters)
        Calling methods and passing arguments
        Method overloading and recursion

Lesson 13: Constructors

    Objective: Understand how to create and use constructors in Java classes.
    Content:
        Defining constructors
        The role of constructors in object initialization
        Overloading constructors

Lesson 14: Access Modifiers and Encapsulation

    Objective: Learn about access modifiers and the principle of encapsulation.
    Content:
        Public, private, and protected access modifiers
        Encapsulation and data hiding
        Getters and setters for controlled access to fields

Lesson 15: Inheritance

    Objective: Understand the concept of inheritance in Java.
    Content:
        Creating subclasses and superclasses
        The extends keyword
        Overriding methods and the use of super

Lesson 16: Polymorphism

    Objective: Learn about polymorphism and its implementation in Java.
    Content:
        Method overriding vs. overloading
        The concept of dynamic binding
        Polymorphism in action (upcasting and downcasting)

Lesson 17: Abstract Classes and Interfaces

    Objective: Understand how to use abstract classes and interfaces in Java.
    Content:
        Defining and using abstract classes
        Implementing interfaces
        The differences between abstract classes and interfaces

### Unit 4: Data Structures

Lesson 18: Arrays

    Objective: Learn how to create and manipulate arrays in Java.
    Content:
        Declaring, initializing, and accessing array elements
        Multidimensional arrays
        Common operations on arrays (traversing, searching, sorting)

Lesson 19: ArrayLists

    Objective: Understand the ArrayList class and its usage.
    Content:
        Creating and manipulating ArrayLists
        Differences between arrays and ArrayLists
        Common ArrayList operations (adding, removing, accessing elements)

Lesson 20: Strings

    Objective: Learn about strings and their manipulation in Java.
    Content:
        Creating and using String objects
        Common String methods (substring, length, indexOf)
        String immutability and memory considerations

Lesson 21: Two-Dimensional Arrays

    Objective: Understand how to use two-dimensional arrays for complex data storage.
    Content:
        Declaring and initializing 2D arrays
        Accessing and modifying elements in 2D arrays
        Applications of 2D arrays (e.g., matrices, grids)

Lesson 22: Recursion

    Objective: Learn about recursion and its application in problem-solving.
    Content:
        Writing recursive methods
        Base cases and recursive cases
        Analyzing the efficiency and limitations of recursion

### Unit 5: Algorithms and Problem-Solving

Lesson 23: Searching Algorithms: Linear and Binary Search

    Objective: Understand the implementation of basic searching algorithms.
    Content:
        Writing a linear search algorithm
        Writing a binary search algorithm
        Comparing the efficiency of linear and binary search

Lesson 24: Sorting Algorithms: Selection and Insertion Sort

    Objective: Learn about basic sorting algorithms and their implementation.
    Content:
        Writing a selection sort algorithm
        Writing an insertion sort algorithm
        Analyzing the time complexity of sorting algorithms

Lesson 25: Merge Sort

    Objective: Understand the merge sort algorithm and its implementation.
    Content:
        The concept of divide and conquer
        Writing a merge sort algorithm
        Comparing merge sort with other sorting algorithms

Lesson 26: Algorithm Efficiency and Big-O Notation

    Objective: Learn how to analyze the efficiency of algorithms using Big-O notation.
    Content:
        Introduction to Big-O notation
        Analyzing time and space complexity
        Applying Big-O notation to common algorithms

## College-Level "Intro to Programming"

    Summary: A more rigorous introduction to programming, building on concepts from AP Computer Science A. This course dives deeper into programming languages, problem-solving techniques, and introduces students to software development tools and practices. It’s designed to prepare students for more complex programming tasks and advanced courses.

## Calculus 1

    Summary: Introduces the fundamental concepts of differential calculus, including limits, derivatives, and their applications. This course provides the mathematical foundation necessary for modeling and solving continuous problems in computer science and other STEM fields.

## Calculus 2

    Summary: Builds on Calculus 1, introducing integral calculus and series. This course is crucial for understanding advanced mathematical concepts that appear in computer graphics, data analysis, and algorithm design.

## Discrete Math and Structures

    Summary: Focuses on the mathematical structures fundamental to computer science, including logic, set theory, combinatorics, and graph theory. This course is essential for understanding algorithms, data structures, and the theoretical foundations of computer science.

## Algorithms and Data Structures

    Summary: This course delves into the design, analysis, and implementation of algorithms and data structures. It builds on the programming and discrete math knowledge from previous courses, teaching students how to efficiently store, manipulate, and retrieve data.
### Unit 1: Introduction to Algorithms and Data Structures

Lesson 1: Introduction to Algorithms

    Objective: Understand what an algorithm is and the importance of algorithms in problem-solving.
    Content:
        Definition of algorithms
        Characteristics of a good algorithm (correctness, efficiency)
        The role of algorithms in computer science

Lesson 2: Introduction to Data Structures

    Objective: Learn the concept of data structures and why they are essential for organizing data.
    Content:
        Definition and classification of data structures (primitive, non-primitive)
        The importance of choosing the right data structure
        Overview of linear vs. non-linear data structures

Lesson 3: Algorithm Analysis and Big-O Notation

    Objective: Understand how to analyze algorithms and measure their efficiency.
    Content:
        Introduction to time and space complexity
        Big-O, Big-Theta, and Big-Omega notations
        Worst-case, best-case, and average-case analysis

### Unit 2: Fundamental Data Structures

Lesson 4: Arrays and Lists

    Objective: Learn about arrays and lists as fundamental data structures.
    Content:
        Static vs. dynamic arrays
        Singly linked lists and doubly linked lists
        Common operations: insertion, deletion, traversal

Lesson 5: Stacks

    Objective: Understand stacks and their applications in algorithms.
    Content:
        LIFO (Last In, First Out) structure
        Implementation using arrays and linked lists
        Applications: Function call stack, expression evaluation

Lesson 6: Queues

    Objective: Learn about queues and their various types and applications.
    Content:
        FIFO (First In, First Out) structure
        Circular queues, priority queues
        Applications: Task scheduling, buffering

Lesson 7: Hash Tables

    Objective: Explore hash tables and their use in efficient data storage.
    Content:
        Hash functions and collision resolution strategies
        Chaining vs. open addressing
        Applications: Caching, symbol tables

### Unit 3: Trees and Hierarchical Data Structures

Lesson 8: Trees and Tree Traversals

    Objective: Understand the basic structure of trees and tree traversal algorithms.
    Content:
        Tree terminology (root, leaves, height, depth)
        Binary trees and binary search trees (BST)
        Traversal algorithms: In-order, pre-order, post-order

Lesson 9: Binary Search Trees (BST)

    Objective: Learn about the structure and operations of binary search trees.
    Content:
        Insertion, deletion, and searching in a BST
        Time complexity of BST operations
        Balanced vs. unbalanced trees

Lesson 10: Heaps and Priority Queues

    Objective: Understand the structure of heaps and their application in priority queues.
    Content:
        Binary heap: Min heap and max heap
        Implementing priority queues using heaps
        Applications: Dijkstra’s algorithm, task scheduling

Lesson 11: Balanced Trees: AVL and Red-Black Trees

    Objective: Explore the concept of balanced trees and their importance in maintaining efficient data structures.
    Content:
        AVL trees: Rotations, insertion, and deletion
        Red-black trees: Properties and operations
        Comparison of AVL and red-black trees in practice

### Unit 4: Graphs and Graph Algorithms

Lesson 12: Introduction to Graphs

    Objective: Learn about graphs, their representation, and basic properties.
    Content:
        Graph terminology (vertices, edges, degree, connectivity)
        Graph representation: Adjacency matrix, adjacency list
        Directed vs. undirected graphs

Lesson 13: Breadth-First Search (BFS)

    Objective: Understand the BFS algorithm and its applications in graph traversal.
    Content:
        BFS algorithm implementation
        Applications: Shortest path in unweighted graphs, network traversal
        Time and space complexity of BFS

Lesson 14: Depth-First Search (DFS)

    Objective: Explore the DFS algorithm and its use in graph traversal.
    Content:
        DFS algorithm implementation
        Applications: Topological sorting, cycle detection
        Time and space complexity of DFS

Lesson 15: Dijkstra’s Algorithm

    Objective: Learn Dijkstra’s algorithm for finding the shortest path in weighted graphs.
    Content:
        Implementation using priority queues
        Applications: Shortest path in road networks, routing algorithms
        Time complexity of Dijkstra’s algorithm

Lesson 16: Minimum Spanning Tree (MST): Kruskal’s and Prim’s Algorithms

    Objective: Understand the concept of minimum spanning trees and algorithms to find them.
    Content:
        Kruskal’s algorithm using union-find
        Prim’s algorithm using priority queues
        Applications: Network design, clustering

Lesson 17: Bellman-Ford Algorithm

    Objective: Learn about the Bellman-Ford algorithm for finding shortest paths in graphs with negative weights.
    Content:
        Difference between Bellman-Ford and Dijkstra
        Applications: Handling negative weight cycles
        Time complexity and use cases

### Unit 5: Advanced Data Structures and Algorithms

Lesson 18: Dynamic Programming

    Objective: Understand the concept of dynamic programming and its applications in optimizing recursive problems.
    Content:
        Overlapping subproblems and optimal substructure
        Examples: Fibonacci, knapsack problem, longest common subsequence
        Memoization vs. tabulation

Lesson 19: Greedy Algorithms

    Objective: Learn about greedy algorithms and their use in optimization problems.
    Content:
        Greedy choice property and optimal substructure
        Examples: Fractional knapsack, activity selection, Huffman coding
        Comparison of greedy vs. dynamic programming approaches

Lesson 20: Divide and Conquer Algorithms

    Objective: Explore divide and conquer as a strategy for algorithm design.
    Content:
        Examples: Merge sort, quick sort, binary search
        Recursion tree method for analyzing time complexity
        Applications of divide and conquer in algorithm design

Lesson 21: Backtracking and Branch-and-Bound

    Objective: Understand backtracking as a technique for solving constraint satisfaction problems.
    Content:
        Backtracking: N-Queens, Sudoku solver
        Branch-and-bound: Knapsack problem, traveling salesman problem
        Comparing backtracking with dynamic programming and greedy approaches

Lesson 22: Advanced Graph Algorithms: Floyd-Warshall and Johnson’s Algorithm

    Objective: Learn about advanced graph algorithms for solving all-pairs shortest path problems.
    Content:
        Floyd-Warshall algorithm: Dynamic programming approach
        Johnson’s algorithm: Handling negative weights efficiently
        Applications in network routing and analysis

### Unit 6: Algorithmic Complexity and Optimization

Lesson 23: NP-Completeness and Computational Intractability

    Objective: Understand the concept of NP-complete problems and the limitations of algorithms.
    Content:
        P vs. NP, NP-hard, and NP-complete problems
        Examples of NP-complete problems: SAT, traveling salesman, clique problem
        Approximation algorithms for intractable problems

Lesson 24: Approximation Algorithms

    Objective: Learn strategies for designing approximation algorithms for NP-complete problems.
    Content:
        Approximation ratio and performance guarantees
        Examples: Vertex cover, traveling salesman, set cover
        Heuristics and probabilistic algorithms
## Introduction to Computer Systems

    Summary: Provides an overview of how computer systems operate, including the interaction between hardware and software. Topics include computer architecture, operating systems, and basic networking. This course lays the groundwork for understanding how programming languages interact with the underlying hardware.

## Programming Language Fundamentals

    Summary: Explores the principles behind programming languages, including syntax, semantics, and paradigms (e.g., object-oriented, functional, procedural). This course helps students understand the design and implementation of programming languages, preparing them for advanced programming tasks.

## Software Design and Testing

    Summary: Introduces the principles of software design, development methodologies, and testing techniques. Students learn how to design maintainable software, write test cases, and understand the software development life cycle. This course prepares students for real-world software engineering challenges.

# Core Module
The Core Module provides a comprehensive understanding of advanced computer science topics, bridging theoretical concepts with practical applications. It prepares students for specialized areas of study and professional work in software development, data science, and system design.

## Linear Algebra

    Summary: Covers vector spaces, matrices, and linear transformations. This course is essential for understanding many advanced topics in computer science, including graphics, machine learning, and data analysis. Linear algebra provides the mathematical tools for dealing with multidimensional data and complex transformations.

## Calculus 3

    Summary: Extends calculus concepts to multiple variables, covering topics such as partial derivatives, multiple integrals, and vector calculus. This course is critical for understanding advanced mathematical models used in computer graphics, machine learning, and scientific computing.

## Operating Systems

    Summary: Provides an in-depth understanding of operating system design and implementation, including process management, memory management, file systems, and system calls. This course is crucial for understanding how software interacts with hardware and how to optimize system performance.

## Introduction to Networking

    Summary: Introduces the fundamentals of computer networking, including network topologies, protocols, and communication models. Students learn about TCP/IP, DNS, and network security. This course is vital for understanding how data is transmitted over networks and the architecture of the internet.

## Databases: Modeling and Theory

    Summary: Focuses on database design, modeling, and theory. Topics include relational databases, normalization, and SQL. This course helps students understand how to design efficient databases, manage data, and perform complex queries.

## Introduction to Machine Learning

    Summary: Introduces the concepts and techniques of machine learning, including supervised and unsupervised learning, neural networks, and model evaluation. This course is essential for students interested in artificial intelligence and data-driven decision-making.

## Computer Graphics

    Summary: Covers the principles and techniques of computer graphics, including rendering, shading, and transformations. Students learn about graphical algorithms and the mathematical foundations behind graphics applications. This course is crucial for developing applications in gaming, simulations, and visualization.

## Enterprise Software Engineering

    Summary: Focuses on software engineering practices in the context of large-scale enterprise applications. Topics include software architecture, design patterns, and project management. This course prepares students for working on complex software projects in professional environments.

## Computational Theory

    Summary: Explores the theoretical foundations of computer science, including automata theory, formal languages, and complexity theory. This course provides a deep understanding of the limits of computation and the theoretical underpinnings of algorithms and data structures.


# Beyond the Core Modules

After completing the core modules, There will be extra modules that will split down two paths: Functional, work-based classes that teach what developers do and academics/theory, that go beyond what is covered in the core modules. For now, I will just start with the ones I have so far and go from there.